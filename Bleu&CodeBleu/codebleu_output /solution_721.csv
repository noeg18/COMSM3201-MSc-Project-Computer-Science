response_num,response,cluster
1,"

def solve(matrix):
    n = len(matrix)
    max_avg = float('-inf')
    path = []
    
    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                continue
            elif i == 0:
                matrix[i][j] += matrix[i][j-1]
            elif j == 0:
                matrix[i][j] += matrix[i-1][j]
            else:
                matrix[i][j] += max(matrix[i-1][j], matrix[i][j-1])
    
    i = n-1
    j = n-1
    while i > 0 or j > 0:
        path.append((i, j))
        if i == 0:
            j -= 1
        elif j == 0:
            i -= 1
        else:
            if matrix[i-1][j] > matrix[i][j-1]:
                i -= 1
            else:
                j -= 1
    
    path.append((0, 0))
    path.reverse()
    return path, matrix[n-1][n-1] / n",1
2,"

def solve(matrix):
    n = len(matrix)
    max_avg = 0
    path = []

    #check for empty matrix
    if n == 0:
        return path

    #calculate the average for each path starting from the top left corner to the bottom right corner
    for i in range(n):
        for j in range(n):
            #initialize current path and sum
            curr_path = [(i,j)]
            curr_sum = matrix[i][j]
            #calculate the sum and add the next position to the current path
            while i < n-1 or j < n-1:
                if i == n-1:
                    j += 1
                elif j == n-1:
                    i += 1
                else:
                    #check which direction (right or down) has a higher value and update the position and current sum accordingly
                    if matrix[i+1][j] > matrix[i][j+1]:
                        i += 1
                    else:
                        j += 1
                #update the current sum and path
                curr_sum += matrix[i][j]
                curr_path.append((i,j))
            #calculate the average for the current path
            curr_avg = curr_sum / len(curr_path)
            #update the maximum average and path if the current average is higher
            if curr_avg > max_avg:
                max_avg = curr_avg
                path = curr_path
    return path",2
3,"

def solve(matrix):
    n = len(matrix)
    max_avg = float('-inf')
    max_path = []
    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                path = [[matrix[i][j]]]
            else:
                path = []
                if i > 0:
                    for p in max_path:
                        path.append(p + [matrix[i][j]])
                if j > 0:
                    for p in max_path:
                        path.append(p + [matrix[i][j]])

            max_path = path
            for p in max_path:
                avg = sum(p) / len(p)
                if avg > max_avg:
                    max_avg = avg
                    max_path = [p]
                elif avg == max_avg:
                    max_path.append(p)

    return max_path[0]",3
4,"

def solve(matrix):
    n = len(matrix)
    max_avg = -float('inf')
    result = []
    for i in range(n):
        for j in range(n):
            if i == 0 and j == 0:
                dp = [[matrix[i][j]]]
            elif i == 0:
                dp[i].append(dp[i][j - 1] + matrix[i][j])
            elif j == 0:
                dp.append([dp[i - 1][j] + matrix[i][j]])
            else:
                dp[i].append(max(dp[i][j - 1], dp[i - 1][j]) + matrix[i][j])
            if i == n - 1 and j == n - 1:
                avg = dp[i][j] / (i + j + 1)
                if avg > max_avg:
                    max_avg = avg
                    result = dp[i][:j + 1]
    return result",4
5,"

def solve(matrix):
    n = len(matrix)
    dp = [[0 for i in range(n)] for j in range(n)]
    dp[0][0] = matrix[0][0]
    for i in range(1, n):
        dp[0][i] = dp[0][i-1] + matrix[0][i]
        dp[i][0] = dp[i-1][0] + matrix[i][0]
    for i in range(1, n):
        for j in range(1, n):
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]
    return dp[n-1][n-1]/(2*n-1)",5
